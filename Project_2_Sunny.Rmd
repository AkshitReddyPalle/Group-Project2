---
title: "Project-6101"
author: "Sunny"
date: "2024-11-29"
output: 
  html_document:
    code_folding: show
    toc: yes
    toc_depth: 3
    toc_float: yes
---
```{r init, include=FALSE}
#library(ezids)
library(dplyr)
library(ggplot2)
library(corrplot)
library(car)
library(ranger)
library(pdp)
```




```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = F, message = F, results = "markup")
options(scipen=999, digits = 5) 
```

# Data


```{r}
data_raw <- read.csv("C:/Users/qluo/Box/DATS 6101/Group-Project2/Combined_SDOH_2019_2020.csv")
```

```{r}
col_indices <- c('COUNTYFIPS','YEAR','ACS_PCT_FEMALE','ACS_PCT_AGE_15_17','ACS_PCT_AGE_18_29','ACS_PCT_AGE_30_44',
                 'ACS_PCT_AIAN_NONHISP','ACS_PCT_ASIAN_NONHISP',
                 'ACS_PCT_BLACK_NONHISP',
                 'ACS_PCT_HISPANIC','ACS_PCT_NHPI_NONHISP','ACS_PCT_OTHER_NONHISP',
                 'ACS_PCT_NOT_LABOR','ACS_MEDIAN_HH_INC','ACS_PCT_HEALTH_INC_BELOW137',
                 'AHRF_UNEMPLOYED_RATE','AHRF_NURSE_MIDWIVES_RATE','CDCW_MATERNAL_DTH_RATE',
                 'POS_MEDIAN_DIST_OBSTETRICS','POS_FQHC_RATE',
                 'POS_HOSP_OBSTETRIC_RATE','POS_HOSP_MEDSURG_ICU_RATE','POS_HOSP_ED_RATE','POS_PCT_HOSP_GOV')
 
subset_data <- data_raw[,col_indices]
colnames(subset_data) <- c('countyfips','YEAR','Percent_femal_pop',"Percent_pop_15_17","Percent_pop_18_29","Percent_pop_30_44",
                           'Percent_pop_American_Indian_and_Alaska_Native','Percent_pop_Asian',
                           'Percent_pop_Black_and_African_American','Percent_pop_Hispanic',
                           'Percent_pop_Native_Hawaiian_and_Pacific_Islander','Percent_pop_other_race',
                           "Percent_pop_not_in_labor_force_16",'Median_household_income',
                           'Percent_pop_under_1.37_of_poverty_threshold',
                           "Unemployment_rate_per_100_population_16",
                           'Number_of_midwives','Maternal_mortality_rate',
                           'Median_distance_to_nearest_obstetrics_department','Numer_of_health_centers',
                           'Number_of_hospitals_with_obstetric','Number_of_hospitals_with_ICU',
                           'Number_of_hospitals_with_emergency_department','Percent_government_hospitals')

```
Considering adding a table to show the variable names and variable labels,or we can divide the variables into different categories, making them clear.

We used CDC Wonder underlying cause of mortality to impute some of the missing maternal mortality rates. We also added the true zeros in maternal mortality rates as reported in CDC wonder. SDOH database did not report the true zeros.

```{r}
library(readxl)
library(dplyr)
library(stringr)

# Function to clean County and State columns
clean_column <- function(column) {
  column %>%
    str_replace_all("\\*|‡|†| ", "") %>%
    str_trim()
}

# Process Impute_2019
impute_2019 <- read_excel("MaternalMortality-addtl-data.xlsx", sheet = "Impute_2019") %>%
  mutate(
    population = as.numeric(population),
    County = clean_column(County)
  ) %>%
  filter(!is.na(County)) %>%
  mutate(
    cnty_fips = str_sub(str_sub(County, -7), 2, 6),
    state_fips = str_sub(cnty_fips, 1, 2)
  )

# Process State_2019
state_2019 <- read_excel("MaternalMortality-addtl-data.xlsx", sheet = "State_2019") %>%
  rename(maternal_multi_st = maternal_multi) %>%
  mutate(
    state = clean_column(state),
    state_fips = str_sub(str_sub(state, -3), 1, 2)
  ) %>%
  filter(!is.na(state))

# Merge 2019 data
merged_2019 <- left_join(impute_2019, state_2019, by = "state_fips") %>%
  group_by(state_fips) %>%
  mutate(
    # Stage 1
    reported_total1 = sum(maternal_multi, na.rm = TRUE),
    gap1 = maternal_multi_st - reported_total1,
    # Stage 2
    dist2 = ifelse(!is.na(all_deaths_under) & is.na(maternal_multi), 1, maternal_multi),
    reported_total2 = sum(dist2, na.rm = TRUE),
    gap2 = maternal_multi_st - reported_total2,
    # Stage 3
    dist3 = ifelse(
      !is.na(all_deaths_under) & is.na(maternal_multi) & maternal_under != 0,
      dist2 + (gap2 / sum(maternal_under, na.rm = TRUE) * maternal_under),
      dist2
    ),
    reported_total3 = sum(dist3, na.rm = TRUE),
    maternal_mortality_rate = dist3 / population * 100000,
    year = 2019
  ) %>%
  ungroup() %>%
  select(County, cnty_fips, maternal_mortality_rate, year)

# Process Impute_2020
impute_2020 <- read_excel("MaternalMortality-addtl-data.xlsx", sheet = "Impute_2020") %>%
  mutate(
    population = as.numeric(population),
    County = clean_column(County)
  ) %>%
  filter(!is.na(County)) %>%
  mutate(
    cnty_fips = str_sub(str_sub(County, -7), 2, 6),
    state_fips = str_sub(cnty_fips, 1, 2)
  )

# Process State_2020
state_2020 <- read_excel("MaternalMortality-addtl-data.xlsx", sheet = "State_2020") %>%
  rename(maternal_multi_st = maternal_multi) %>%
  mutate(
    state = clean_column(state),
    state_fips = str_sub(str_sub(state, -3), 1, 2)
  ) %>%
  filter(!is.na(state))

# Merge 2020 data
merged_2020 <- left_join(impute_2020, state_2020, by = "state_fips") %>%
  group_by(state_fips) %>%
  mutate(
    # Stage 1
    reported_total1 = sum(maternal_multi, na.rm = TRUE),
    gap1 = maternal_multi_st - reported_total1,
    # Stage 2
    dist2 = ifelse(!is.na(all_deaths_under) & is.na(maternal_multi), 1, maternal_multi),
    reported_total2 = sum(dist2, na.rm = TRUE),
    gap2 = maternal_multi_st - reported_total2,
    # Stage 3
    dist3 = ifelse(
      !is.na(all_deaths_under) & is.na(maternal_multi) & maternal_under != 0,
      dist2 + (gap2 / sum(maternal_under, na.rm = TRUE) * maternal_under),
      dist2
    ),
    reported_total3 = sum(dist3, na.rm = TRUE),
    maternal_mortality_rate = dist3 / population * 100000,
    year = 2020
  ) %>%
  ungroup() %>%
  select(County, cnty_fips, maternal_mortality_rate, year)

# Combine 2019 and 2020 data
combined <- bind_rows(merged_2019, merged_2020)

# View final combined data
print(combined)
```

```{r}

# Ensure COUNTYFIPS in subset_data is formatted as a 5-digit string
subset_data <- subset_data %>%
  mutate(
    countyfips = sprintf("%05d", as.integer(countyfips))
  )

# Join subset_data with combined on YEAR and COUNTYFIPS/cnty_fips
merged_data <- subset_data %>%
  left_join(
    combined,
    by = c("YEAR" = "year", "countyfips" = "cnty_fips")
  )

# Fill missing Maternal_mortality_rates in subset_data with values from combined
subset_data <- merged_data %>%
  mutate(
    Maternal_mortality_rate = ifelse(
      is.na(Maternal_mortality_rate),
      maternal_mortality_rate,
      Maternal_mortality_rate
    )
  ) %>%
  select(-maternal_mortality_rate,-countyfips, -YEAR,-County) # Remove unnecessary columns if desired
# View the updated subset_data
print(subset_data)
```

```{r}
sum(complete.cases(subset_data))
subset_data <- na.omit(subset_data)
```


```{r}
hist(subset_data$Maternal_mortality_rate)

```




```{r}
model <- lm(Maternal_mortality_rate ~ ., data=subset_data)
vif_values <- vif(model)
print(vif_values)

```
The VIF values are relatively high for `Median_household_income` and `Percent_pop_under_1.37_of_poverty_threshold`. Doing the correlation test to check the multicolinearity.    

```{r}
#Pearson correlation (default)
cor.test(subset_data$Median_household_income, subset_data$Percent_pop_under_1.37_of_poverty_threshold, method = "pearson")

# Spearman correlation
cor.test(subset_data$Median_household_income, subset_data$Percent_pop_under_1.37_of_poverty_threshold, method = "spearman")

```
The coefficients for the two variables are higher than 0.8. Drop `Median_household_income` and run the model 
```{r}
# Fit a model excluding Median_household_income
model_1 <- lm(Maternal_mortality_rate ~ . - Percent_pop_under_1.37_of_poverty_threshold, data = subset_data)

# View summary
summary(model_1)

```


```{r}
par(mfrow = c(2, 2))  # Set up a 2x2 plot grid
plot(model_1)


```

```{r}
residuals <- residuals(model_1)
hist(residuals, main = "Histogram of Residuals", xlab = "Residuals")
```


```{r}
# Hyperparameter tuning for random forest regression tree 
# Define the tuning grid: include additional parameters
tuning_grid <- expand.grid(
  num.trees = c(100, 200, 300, 500),
  mtry = 1:(ncol(subset_data) - 1),
  splitrule = c("variance",'extratrees','maxstat'),    # Split rule for regression
  min.node.size = c(1, 5, 10),
  max.depth = c(0, 5, 10, 20)
)

# Randomly sample 60 combinations from the grid
set.seed(456)
random_combinations <- tuning_grid[sample(nrow(tuning_grid), 60), ]

# Cross-validation function
cross_validate <- function(data, formula, params, k = 5) {
  folds <- sample(1:k, nrow(data), replace = TRUE)
  scores <- numeric(k)
  
  for (i in 1:k) {
    # Split data into training and validation sets
    train_data <- data[folds != i, ]
    val_data <- data[folds == i, ]
    
    # Fit the model
    model <- ranger(
      formula = formula,
      data = train_data,
      splitrule = params$splitrule,
      num.trees = params$num.trees,
      mtry = params$mtry,
      min.node.size = params$min.node.size,
      max.depth = params$max.depth,
      num.threads=16
    )
    
    # Predict and calculate RMSE
    predictions <- predict(model, val_data)$predictions
    scores[i] <- sqrt(mean((val_data$Maternal_mortality_rate - predictions)^2))
  }
  
  # Return mean RMSE across folds
  mean(scores)
}

# Perform random search
results <- data.frame(random_combinations, RMSE = NA)

for (i in 1:nrow(random_combinations)) {
  if (i%%50==0)(
    cat(paste(".    ",i,"\r"))
  )
  else{
    cat(".")
  }
  params <- random_combinations[i, ]
  results$RMSE[i] <- cross_validate(
    data = subset_data,
    formula = Maternal_mortality_rate ~ .,
    params = params
  )
}
```


```{r}

# Find the best combination
best_model <- results[which.min(results$RMSE), ]
best_model

```


```{r}
# Fit the Final Tree-Based Model
library(randomForest)
set.seed(123)
final_rf_model <- ranger(
  Maternal_mortality_rate ~ .,
  data = subset_data,
  num.trees = best_model$num.trees,
  splitrule = best_model$splitrule,
  mtry = best_model$mtry,
  min.node.size = best_model$min.node.size,
  max.depth = best_model$max.depth,
  num.threads=16,
  importance='permutation'
  )


```

```{r}
print(final_rf_model)
```
```{r}
# Partial dependence for multiple features
features <- c("Percent_pop_Black_and_African_American","Percent_pop_30_44",'Median_distance_to_nearest_obstetrics_department','Number_of_hospitals_with_obstetric','Median_household_income')


# Loop to generate and print plots

for (feature in features) {
  pd <- partial(
    object = final_rf_model,
    pred.var = feature,
    train = subset_data,
    pred.fun = function(object, newdata) {
      predict(object, data = newdata)$predictions
    }
  )
  
  # Convert partial dependence to a data frame
  pd_df <- as.data.frame(pd)
  # Apply spline smoothing
  spline_fit <- smooth.spline(pd_df[,feature], pd_df$yhat, spar = 0.7)  # spar = smoothing parameter
  
  # Convert spline results to a data frame for ggplot
  spline_df <- data.frame(
    feature = spline_fit$x,
    yhat_smooth = spline_fit$y
  )
  colnames(spline_df)[1] <- feature
  # Create a proper ggplot
  print(ggplot(spline_df, aes_string(x = feature, y = "yhat_smooth")) +
    geom_line() +
    ggtitle(paste("Partial Dependence of", feature)) +
    xlab(feature) +
    ylab("Predicted Maternal Mortality Rate") +
    theme_minimal())
}
```


```{r}
# Extract the importance metrics as a named vector
importance_metrics <- final_rf_model$variable.importance

# Convert to a data frame for easier manipulation
importance_df <- data.frame(
  Variable = names(importance_metrics),
  `%IncMSE` = importance_metrics
)

# Sort by `%IncMSE` in descending order
sorted_by_mse <- importance_df[order(-importance_df$`X.IncMSE`), ]

# View the sorted importance
print(sorted_by_mse)
```


The column `%IncMSE` stands for percentage increase in Mean Squared Error.
Measures how much the model’s prediction error increases when a particular variable is randomly permuted while keeping all other variables unchanged..
Higher values indicate that the variable is important for the model's predictive accuracy.It reflects the variable's contribution to the overall model performance.
The column `IncNodePurity` stands for Increase in Node Purity.
Reflects the total decrease in node impurity (measured by RSS for regression) attributed to splits involving this variable.
Higher values suggest that the variable contributes significantly to better node splits.

```{r}
# Adjust margins for longer labels
par(mar = c(10, 5, 2, 2))  # Increase bottom margin

# Bar plot with adjusted margins
barplot(sorted_by_mse[, "X.IncMSE"],
        names.arg = rownames(sorted_by_mse),
        las = 2,
        col = "skyblue",
        main = "Variable Importance by %IncMSE",
        ylab = "%IncMSE",
        cex.names = 0.5)
```


Socioeconomic Factors

The coefficients for `Percent_pop_Black_and_African_American`, `Percent_pop_Asian`, and `Percent_pop_Hispanic` are positive and significant, suggesting that a higher percentage of these racial populations is associated with increased maternal mortality. This highlights the impact of systemic inequities and potential disparities in healthcare access.

Solution:

Address racial disparities by improving access to healthcare for minority populations.
Implement culturally tailored maternal health programs to meet the specific needs of these communities.
Invest in training healthcare providers to ensure culturally competent and bias-free care.

Demographic Trends

The coefficients for `Percent_pop_30_44` and `Percent_femal_pop` are positive and highly significant, while the coefficients for `Percent_pop_15_17` and `Percent_pop_18_29` are significantly negative. This indicates that counties with a higher percentage of women aged 30-44 experience higher maternal mortality rates. It suggests that earlier pregnancies may reduce maternal mortality risks.

Solution:

Provide policy support to enable younger women to start families, such as affordable childcare, flexible work arrangements, and enhanced parental leave policies.
Raise awareness of the potential risks of delayed childbearing and provide comprehensive prenatal care for older mothers.

Healthcare Access

The coefficient for `Median_distance_to_nearest_obstetrics_department` is negative and highly significant, indicating that greater distances to obstetric care facilities are associated with higher maternal mortality rates. Similarly, the coefficients for `Number_of_hospitals_with_obstetric` and `Percent_government_hospitals` are negative and significant, suggesting that increasing the number of hospitals with obstetric departments or government hospitals reduces maternal mortality.

Solution:

Expand access to obstetric care facilities in underserved areas.
Build or upgrade healthcare infrastructure in regions lacking obstetric and maternal care services.
Encourage partnerships between public and private sectors to fund and establish obstetric departments in existing hospitals.

Economic Disparities

The coefficient for `Median_household_income` is negative and significant, while the coefficient for `Unemployment_rate_per_100_population_16` is positive and significant. These findings indicate that counties with higher income levels and lower unemployment rates tend to have lower maternal mortality.

Solution:

Strengthen socioeconomic support for low-income and unemployed populations.
Expand access to healthcare subsidies, prenatal care programs, and financial assistance for underserved communities.
Implement workforce development programs to reduce unemployment and improve economic stability in high-risk counties.
